参考文章

1. [自己对go协程的理解](https://www.jianshu.com/p/4267cfbbc2d1)
    - qq群"天天"大神写的, 比较亲民
2. [go语言调度器源代码情景分析](https://mp.weixin.qq.com/mp/homepage?__biz=MzU1OTg5NDkzOA%3D%3D&hid=1)
    - 微信系列文章

如果把`GMP`整体框架看作是线程池+任务调度, 那么`P`就是对"线程数量"的限制.

> 该值默认为1, 由`GOMAXPROCS`环境变量在程序启动初始控制, 但当前版本还无法根据当前系统线程数量(即`M`的数量)弹性扩缩容.

但是这种说法只是简化了理解, `P`只是`M`执行`G`任务的前提条件, 默认只有一个`P`时, 仍然可以因此`G`的增多而`fork`出更多的`M`. 

由于`P`的限制, 多出来的`M`只能休眠, 等待能够获取到`P`后, 才真正的执行`G`, 所以真正的并发只有1. (这种理解对不对, 好像有点python的`GIL`的感觉了 ???)

因此可以再换一种更精确的说法, P表示可以同时运行的线程数量, M则表示当前进程中所有子线程的数量(包含了休眠的线程);

> GOMAXPROCS 设置了 P 的数量;
>
> runtime/debug.SetMaxThreads() 则可以设置 M 的数量;

## 系统线程M的伸缩

GMP框架中, M遍历G并执行, 那多余的M是根据什么判断出来的, 会自动退出吗? 如何实现的?

G对象怎么判断自己进入阻塞, 如何告诉M去执行其他G? 当前谁告知阻塞的G已经完成了, 可以继续执行的?

调度器会在什么情况下新建/回收 m 对象, 根据什么判断??? 

目前引起`G`任务阻塞的, 可能有如下几种情况

1. channel读写缓冲满;
2. Mutex互斥锁占用;
3. 陷入系统调用(open,read,close等);

其中, 1、2是golang的内部实现, G任务陷入阻塞时会主动休眠让出M, M会自行寻找其他待执行的G.

反而是第3种

```
startm()
|
---- newm(fn, p)
     |
     ---- runtime·newosproc()
          |
          ---- runtime·clone(runtime·mstart)
               |
               ---- runtime·mstart()
                    |
                    ---- m->mstartfn() + schedule()
```

## g0主协程 + m0主线程

golang 运行时中, 是否存在 g0, m0 这种"主协程"的概念, 主要用来做什么?

有, g0 == m0.g0, 此关系一直成立. 但是 m 中还存在一个 m.curg, 这个才是当前 m 绑定的 g.

m0 可以与 g0 解绑(即 m0.curg != g0), 然后去执行其他 g 任务.

只有 m0 和 g0 绑定时, 才可以执行一此特殊的操作.

可以通过`if(g == m->g0)`, `if(g != m->g0)`查看有哪些操作必须由 g0 执行.

比如`runtime·mcall(fn)`就是切换到 m->g0 的上下文, 执行目标函数.

所谓的主线程, 全局唯一, 具有特殊性.

1. 主线程的线程 tid 即是进程 pid, 而子线程的 tid 则不一样.
2. 主线程才能接收并处理来自控制台终端的 signal 信号.
3. gc时, STW 完成后, 只剩下 m0, 之后实际的 gc 行为也是由 m0 发起.
