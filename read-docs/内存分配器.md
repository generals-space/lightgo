参考文章

1. [Go语言内存分配器设计](http://skoo.me/go/2013/10/08/go-memory-manage-system-design)
    - 2013-10-08, go1.1.2
    - skoo系列文章1
2. [Go语言内存分配器-FixAlloc](http://skoo.me/go/2013/10/09/go-memory-manage-system-fixalloc)
    - 2013-10-09, go1.1.2
    - skoo系列文章2
3. [Go语言内存分配器-MSpan](http://skoo.me/go/2013/10/11/go-memory-manage-system-span)
    - 2013-10-11, go1.1.2
    - skoo系列文章3
4. [Go语言内存分配器的实现](http://skoo.me/go/2013/10/13/go-memory-manage-system-alloc)
    - 2013-10-13, go1.1.2
    - skoo系列文章4
5. [图解Golang的内存分配](https://blog.csdn.net/i6448038/article/details/91356580)

```
                FixAlloc
                    ↓ 
       +-----------------------+ 
       | ...... | chunk | list |
       +------------|-------|--+ 
                    |       ↓
                    |       +--------+    +--------+    +--------+
                    |       | *MLink | -> | *MLink | -> | *MLink |
                    |       +--------+    +--------+    +--------+
                    ↓
                    +-----------------------+ 
                    |          128k         |
                    +-----------------------+ 
```

1. `MLink`是通用链表结构, 任何结构都可以通过引入ta为成员而成为链表. 
2. 在分配器中, mheap只有两个成员是FixAlloc类型: `cachealloc`和`spanalloc`. `cachealloc`对象的list链表中, 存储的内存块为`MCache`, 而在`spanalloc`对象的list链表中, 存储的内存块为`MSpan`.
                  |
        +----+----|--------------------------+--------------------------+
        | x1 | x1 |            x16           |            x16           |
        +----+----|--------------------------+--------------------------+
           |   └────────────────┘                          ↑
           └───────────────────────────────────────────────┘


关于内存的三段布局, span, bitmap和arena, 说白了这仨都应该算**堆空间**. 

span和bitmap分别是arena在page(页)和object(对象)两个维度的索引区域.

那么可能又有这样的疑问, 按照参考文章5第一张图, 一般进程在内存空间中分为如下段

- 全局段(全局变量, 静态变量)
- 栈段(基础类型的局部变量)
- 堆段()
- TEXT段()
- 程序代码段()

其中对于栈段的解释需要注意: 栈空间不是由进程运行时, 更不是由开发者能够管理的. 每创建新的栈帧都需要向操作系统申请, 并由操作系统进行管理.

运行时的内存管理只是针对堆空间来说的, 因为开发可以手动通过new/delete向OS申请/释放内存空间, 所以这才是内置运行时的高级语言优化的点.

现在问题来了, 在源码`mgc0.c`中, `addstackroots()`->`addframeroots()`->`scanbitvector()`, 分析函数源码你会发现这分明还是堆空间的管理. 

关于这一点, 我的理解是, 在golang中, 就算是栈帧(`Stkframe`对象), 也是存放在堆空间的`arena`区的. 同理还有函数对象, 基础变量类型等. 在涉及函数调用时, 仍然是由操作系统管理的, 顶多这部分(比如函数符号表)与开发者自己分开一点, 毕竟函数对象也是对象, 栈帧对象也是对象, 为什么不能和struct对象一样, 放在堆空间中呢?
