参考文章

1. [Golang 1.3 sync.Mutex 源码解析](https://studygolang.com/articles/1472)
    - 代码分析的很详细, 透彻.
2. [Windows线程同步（上）](https://www.cnblogs.com/predator-wang/p/5125590.html)

golang 1.2 的时候还没自旋锁的概念.

`mutex.go`中调用的`runtime_Semacquire()`, 实际需要追踪到`sema.goc`文件中的`runtime·semacquire()`.


## 自旋锁为什么性能更好?

> 旋转计数可以在多处理器计算机上提供更佳性能，其原因在于在一个循环中旋转通常要快于进入内核模式等待状态。 --参考文章2

以信号量做对比.

信号量是OS提供的同步机制, 在调用 acquire 操作(即P操作)挂起当前线程/进程时, 需要进入内核模式休眠, 之后再由内核唤醒. 

我们知道从用户模式到内核模式切换是十分费时的, 而 spin 自旋锁则是在未成功获得锁时, 停留在用户模式, 执行一遍类似于for循环n次的操作, 然后再重新抢占.

在每个线程执行的任务都极为迅速, 耗时极短的情况下, 停留在用户模式空循环n次的效率要远远高于信号量等机制的.
