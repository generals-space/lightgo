参考文章

1. [Go语言高级编程 - 3.1 快速入门](https://www.jishuchi.com/read/GO/680)
    - Go官网自带了一个Go汇编的入门教程, [地址](https://golang.org/doc/asm)
    - `DATA symbol+offset(SB)/width, value`各字段的解释
2. [Go语言高级编程 - 3.2 计算机结构](https://www.jishuchi.com/read/GO/681?wd=http)
    - Go汇编的伪寄存器与真实寄存器对应示意图
    - Go汇编为了简化汇编代码的编写，引入了PC、FP、SP、SB四个伪寄存器
    - 四个伪寄存器加其它的通用寄存器就是Go汇编语言对CPU的重新抽象，该抽象的结构也适用于其它非X86类型的体系结构
    - 介绍了伪寄存器所表示的含义
    - **伪寄存器一般需要一个标识符和偏移量为前缀，如果没有标识符前缀则是真寄存器。**
3. [Go 系列文章3 ：plan9 汇编入门](http://xargin.com/plan9-assembly/)
    - Go 使用了 Unix plan9 汇编, 与 x86 汇编有些许区别
    - plan9 中使用寄存器不需要带 r 或 e 的前缀，例如 rax，只要写 AX 即可
    - golang汇编指令解释, 比较详细.
    - 真实寄存器与伪寄存器的对应关系(ASCII图)
    - caller/callee 调用栈示意图(ASCII图)
4. [Go汇编学习 1.进程内存地址与寄存器](https://mzh.io/进程内存地址空间/)
    - 比较简单...但是是参考文章3的参考文章
5. [golang内核系列--深入理解plan9汇编&实践](https://zhuanlan.zhihu.com/p/56750445)
    - 详细性比得上参考文章3
6. [Golang 从汇编看函数调用](https://laily.net/article/Golang%20从汇编看函数调用)
    - `go tool compile`编译成汇编代码并分析
7. [Golang汇编命令解读](https://www.cnblogs.com/yjf512/p/6132868.html)
    - golang代码编译为汇编代码的示例分析
    - golang多返回值的实现方法
8. [Go Assembly 学习笔记](https://segmentfault.com/a/1190000010984538)
    - 汇编代码示例分析及注释
9. [手把手教你栈溢出从入门到放弃（上）](https://zhuanlan.zhihu.com/p/25816426)
    - 函数调用中, 栈的变化过程, 与本文中的图像描述相符, 可以借鉴.

```
go tool compile -S main.go >> main.S
```

生成汇编文件 `main.S`

Go汇编为了简化汇编代码的编写, 引入了PC、FP、SP、SB四个**伪寄存器**. 四个伪寄存器加其它的通用寄存器就是Go汇编语言对CPU的重新抽象, 该抽象的结构也适用于其它非X86类型的体系结构. 

在AMD64环境, 

- 伪`PC`寄存器: 其实是IP指令计数器寄存器的别名. 
- 伪`FP`寄存器: 对应的是函数的帧指针, 一般用来访问函数的参数和返回值. 
- 伪`SP`寄存器: 栈指针, 对应的是当前函数栈帧的顶部(不包括参数和返回值部分), 一般用于**定位局部变量**. 
    - 伪SP是一个比较特殊的寄存器, 因为还存在一个同名的SP真寄存器. 
- 真`SP`寄存器: 对应的是栈的底部, 一般用于定位调用其它函数的参数和返回值;
- 伪`SB`寄存器: 全局静态基指针, 一般用来声明函数或全局变量;

```asm
               用于声明函数   参数及返回值大小
                   |              | 
 TEXT pkgname·add(SB),NOSPLIT,$64-32
       |       |               |
      包名    函数名          栈帧大小
```

> 栈帧大小: 局部变量+可能需要的额外调用函数的参数空间的总大小, 但不包括调用其它函数时的 ret address 的大小

比如函数内部声明两个`int32`变量, 就需要64 bytes栈帧空间, 而返回一个`int32`变量.

栈帧大小为0时, 表示该函数没有局部变量, 也不需要调用其他函数, 不需要占用栈空间, 只使用寄存器. 此时, 伪SP与真SP指向同一位置.

如果没有本地变量：伪SP=硬件SP+8
如果有本地变量：伪SP=硬件SP+16+本地变量空间大小

> 使用 FP 时必须使用`symbol+offset(FP)`的形式, 不加symbol无法通过编译(此时FP为虚拟FP).

------

栈空间中的某个函数的结构.

```
                       -----------------                                           
                       current func arg0                                           
                       ----------------- <----------- FP(pseudo FP)                
                        caller ret addr                                            
                       +---------------+                                           
                       | caller BP(*)  |                                           
                       ----------------- <----------- SP(pseudo SP, 实际上是当前栈帧的 BP 位置)
                       |   Local Var0  |                                           
                       -----------------                                           
                       |   Local Var1  |              1. 局部变量区域                                
                       -----------------                                           
                       |   ........    |                                           
                       -----------------                                           
                       |   Local VarN  |                                           
                       ----------------- <------------ hardware SP 位置             
                       |               |                                           
                       |  temporarily  |                                           
                       |  unused space |                                           
                       |               |                                           
                       -----------------                                           
                       |  call retn    |                                           
                       -----------------              2. 返回值区域                                
                       |  call ret(n-1)|                                           
                       -----------------                                           
                       |  ..........   |                                           
                       -----------------                                           
                       |  call ret1    |                                           
                       -----------------                                           
                       |  call argn    |                                           
                       -----------------                                           
                       |   .....       |                                           
                       -----------------              3. 参数列表区域                               
                       |  call arg2    |                                           
                       |---------------|                                           
                       |  call arg1    |                                           
                       -----------------            
                       | return addr   |                                           
                       +---------------+                                           
```

注意: 除了参数argn, 还有retn, 这也是golang能够多值返回的原因.

------

栈和栈帧

栈(stack)相对整个系统而言, 调用栈(Call stack)相对某个进程而言, 栈帧(stack frame)则是相对某个函数而言, 调用栈就是正在使用的栈空间, 由多个嵌套调用函数所使用的栈帧组成. 

具体来说, Call stack就是指存放某个程序的正在运行的函数的信息的栈. Call stack 由 stack frames 组成, 每个 stack frame 对应于一个未完成运行的函数. 

在当今多数计算机体系架构中, 函数的参数传递、局部变量的分配和释放都是通过操纵栈来实现的. 栈还用来存储返回值信息、保存寄存器以供恢复调用前处理机状态. 每次调用一个函数, 都要为该次调用的函数实例分配栈空间. **为单个函数分配的那部分栈空间就叫做 `stack frame`**, 或者这样说, stack frame 这个说法主要是为了描述函数调用关系的. 

Stack frame 组织方式的重要性和作用体现在两个方面:

第一, 它使调用者和被调用者达成某种约定. 这个约定定义了函数调用时函数参数的传递方式, 函数返回值的返回方式, 寄存器如何在调用者和被调用者之间进行共享;
第二, 它定义了被调用者如何使用它自己的 stack frame 来完成局部变量的存储和使用. 

------

```
                                       caller                                                                              
                          FP     +------------------+                                                                      
                                 |                  |                                                                      
       +---------------------->  --------------------                                                                      
       |                         | caller parent BP |                                                                      
       |           BP(pseudo SP) --------------------                                                                      
       |                         |   Local Var0     |                                                                      
       |                         --------------------                                                                      
       |                         |   .......        |                                                                      
       |                         --------------------                                                                      
       |                         |   Local VarN     |                                                                      
       |        SP(Real Register)--------------------                                                  
 caller stack frame              |   callee arg2    |                                                                      
       |                         |------------------|                                                                      
       |                         |   callee arg1    |                                                                      
       |                         |------------------|                                                                      
       |                         |   callee arg0    |                                                                      
       |                         ---------------------------------------------+  FP(virtual register)                  
       |                         |   return addr    |  parent return address  |                            ## 1. 这里存储的是主调函数在调用语句完成后的下一句代码的地址, 作为被调函数的返回地址
       +---------------------->  +------------------+--------------------------    <------------------------+         
                                                    |     caller BP           |     (caller frame pointer)  |           ## 2. 主调函数的起始地址, 即主调函数的FP
                                     BP(pseudo SP)  ---------------------------      FP(Real register)      |         
                                                    |     Local Var0          |                             |         
                                                    ---------------------------                             |         
                                                    |     Local Var1          |                                       
                                                    ---------------------------                     callee stack frame
                                                    |       .....             |                                       
                                                    ---------------------------                             |         
                                                    |     Local VarN          |                             |         
                                  SP(Real Register) ---------------------------                             |         
                                                    |                         |                             |         
                                                    |                         |                             |         
                                                    +-------------------------+    <------------------------+         
                                                              callee
```
